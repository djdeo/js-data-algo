# Data structure and algorithsm

## 链表

- 单向链表
- [双向链表](./linkedList.js)

## 集合

集合由 **无序的**， **不能重复的**的元素构成，相当于ES6 中的 Set 类
常见的实现方式：哈希表

## 哈希表

基于数组但效率比数组的插入，删除，查找（基于数据）高， 但

- 哈希表中的数据是 *无序的*
- 表中的 *key* 通常不能重复
- 空间利用率其实并不是很高
- 查最大值，最小值效率很低

### 哈希函数

要求能够：快速计算 && 均匀分布

1. 字母转数字方案
	+ 编码结果相加
	+ 编码幂的连乘
	+ 哈希化
	+ 处理冲突
		+ 链地址法（拉链法）：每个下标不直接放值，放一个数组/链表， 效率较高
		+ 开放地址法：寻找空白单元格存放
			+ 线性探测
			+ 二次探测，解决聚集问题
			+ 再哈希法


步长公式： stepSize = constant - (key % constant)
constant 为 质数

### 哈希表封装

1. 属性
	- 一个数组， storage
	- 数量， count => loadFactor
	- 上限， limiit, 质数
2. 方法
	- hashFun
	- put
	- get
	- remove
	- isEmpty
	- size

### 哈希表扩容

- 扩大两倍
- 所有数据同时修改
- 当 `loadFactor>0.75` 的时候进行扩容

1. 保存旧的数组
2. 重置所有属性
3. 遍历旧数组元素并重新放入新容器


## 树结构

### 树的优点

- 非线性结构，可以表示一对多的关系 （目录结构）


### 树的术语

- Tree
- Root
- SubTree
- 节点度 （Degree）
- 树的度 
- Leaf，叶子节点，度为0的节点
- 前驱
- 后继

### 树的表示方式

- son, sibling 表示法

new Node(data, leftchild)

### 二叉树

每一树的节点最多有两个子节点，任何树都可以用二叉树模拟， 具有以下特性

- 第i层的最大节点数： 2^(i-1), i>=1
- 深度为k的最大节点数：2^k - 1, k>=1
- 对于非空二叉树，叶子节点 n0, 与度为2节点n2节点关系： n0 = n2 + 1

### 分类

- 完全二叉树可以用数组表示
- 常见二叉树可以用链表表示

### 二叉搜索树

或 二叉排序树/二叉查找树 (BST, Binary Search Tree)

非空二叉搜索树满足以下性质：

- 非空左子树的所有键值小于其根节点的键值
- 非空右子树的所有键值大于其根节点的键值
- 左右子树本身也都是二叉搜索树

这些特性使得查找效率非常高

方法：

- insert(key)
- search(key)
- remove(key) (难点)
	+ 先查找要删除的节点，没有的返回 `false`
	+ 找到删除节点
		+ 删除叶子节点
		+ 删除只有一个节点的节点
		+ 删除有两个节点的节点
- midOrderTraversal: 中序遍历
	+ 中序遍历其左子树
	+ 访问根节点
	+ 中序遍历其右子树
- preOrderTraversal: 先序
	+ 访问根节点
	+ 先序遍历其左子树
	+ 先序遍历其右子树
- postOrderTraversal: 后序
	+ 后序遍历其左子树
	+ 访问根节点
	+ 后序遍历其右子树
- min
- max

### 二叉搜索树的缺陷

插入有序的数据时，层级会变得很多，成为了 **非平衡树**， 相当于写了一个链表，查找效率变成了 O(N), 而 **平衡树** 的效率是 O(logN)

保证每个节点的左边子孙节点数 尽可能等于 右边的之孙节点数 是生成平衡树的关键


### 常见的平衡树

- AVL树 (outdated)
- 红黑树 (better solution)



